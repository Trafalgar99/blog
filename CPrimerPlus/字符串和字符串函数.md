# 字符串和字符串函数

> 函数：gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、 strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()
> 创建并使用字符串
> 使用C库中的字符和字符串函数，并创建自定义的字符串函数
> 使用命令行参数


## 表示字符串和字符串IO
> 字符串是以空字符（\0）结尾的char类型数组

和printf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。但 是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符.

**在程序中定义字符串**

1. 字符串字面量（字符串常量）
   
从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符 分隔，C会将其视为串联起来的字符串字面量。例如：
```C
char　greeting[50]　=　"Hello,　and""　how　are"　"　you"
"　today!";

//与下面的代码等价：
char greeting[50] = "Hello, and how are you today!";
```

*字符串常量属于静态存储类别（static storage class），这说明如果在函 数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存 在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存 位置的指针。这类似于把数组名作为指向该数组位置的指针。*

2. 字符串数组和初始化
> 定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足 够空间的数组储存字符串。

```C
const char m1[40] = "Limit yourself to one line's worth.";
```

*在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为 了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是 char形式的空字符，不是数字字符0）*


还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面 的声明：
```C
const char * pt1 = "Something is pointing at me.";
//该声明和下面的声明几乎相同：
const char ar1[] = "Something is pointing at me.";
```

3. 数组和指针
  > 初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针 只把字符串的地址拷贝给指针
  >在数组形式中，ar1是地址常量。不能更改ar1，如果 改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似 ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操 作。
  > 指针形式（*pt1）也使得编译器为字符串在静态存储区预留29个元素的 空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置， 并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符， 但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符


4. 数组和指针的区别

假设有下面两个声明：
```C
char heart[] = "I love Tillie!"
const char *head = "I love Tillie!"
```
两者主要的区别是：数组名heart是常量，而指针名head是变量。

两者都可以使用数组表示法

两者都能进行指针加法操作

只有指针表示法可以进行递增操作

建议在把指针初始化为字符串字面 量时使用const限定符

----------------------------------
5. 字符串数组

```C
const char *mytalents[LIM] = {
"Adding　numbers　swiftly",
"Multiplying　accurately",　"Stashing　data",
"Following　instructions　to　the　letter",
"Understanding　the　C　language"
};

char　yourtalents[LIM][SLEN]　=　{
"Walking　in　a　straight　line",
"Sleeping",　"Watching　television",
"Mailing　letters",　"Reading　email"
};
```

从某些方面来看，mytalents和yourtalents非常相似。两者都代表5个字符 串。使用一个下标时都分别表示一个字符串，如mytalents[0]和 yourtalents[0]；使用两个下标时都分别表示一个字符，例如 mytalents[1][2]表 示 mytalents 数组中第 2 个指针所指向的字符串的第 3 个字符'l'， yourtalents[1][2]表示youttalentes数组的第2个字符串的第3个字符'e'。而且， 两者的初始化方式也相同。

mytalents数组是一个内含5个指针的数组，在我们的系统中共占用40字节.而yourtalents是一个内含5个数组的数组，每个数 组内含40个char类型的值，共占用200字节。所以，虽然mytalents[0]和 yourtalents[0]都分别表示一个字符串，但mytalents和yourtalents的类型并不相 同。mytalents中的指针指向初始化时所用的字符串字面量的位置，这些字符 串字面量被储存在静态内存中；而 yourtalents 中的数组则储存着字符串字面 量的副本，所以每个字符串都被储存了两次。此外，为字符串数组分配内存 的使用率较低。yourtalents 中的每个元素的大小必须相同，而且必须是能储 存最长字符串的大小。

*综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数 组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。
mytalents 中的指针指向的字符串字面量不能更改；而yourtalentsde 中的内容 可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指 向字符串字面量的指针*

------------------------

## 字符串输入

**分配空间**
> 如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然 后用输入函数获取该字符串
> 要做的第 1 件事是分配空间，以储存稍后读入的字符串。

**gets函数**

在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序 中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就 用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行 符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符 使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字 符串，并在末尾添加换行符。

*gets()函数只知道数组的开始处，并不知道数组中有多少个元 素。如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多 余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用 的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致 程序异常中止；或者还有其他情况。*

*C11标准委员会采取了更强硬的态度，直接从标准中废除了 gets()函数*

**gets的替代品**

> 通常用fgets()来代替gets()，C11标准新增的gets_s()函数也可代替gets()。该函数与 gets()函数更接近，而且可以替换现有代码中的gets()。

1. fgets和fputs

   fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函 数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和 gets()的区别如下。
    + fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值 是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。
    + 如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不 同，gets()会丢弃换行符
    + fgets()函数的第3 个参数指明要读入的文件。如果读入从键盘输入的数 据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。
    + 因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通 常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在 计算机显示器上，应使用stdout（标准输出）作为该参数。
    + puts()函数会在待输出字符串末尾添加一个换行符，而fputs()不会这样做。

