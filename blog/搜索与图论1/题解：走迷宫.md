# 题解：走迷宫

**问题描述**：

给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。

最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。

数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。

**输入格式**

第一行包含两个整数n和m。

接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。

**输出格式**

输出一个整数，表示从左上角移动至右下角的最少移动次数。

**数据范围**

1≤n,m≤100

**样例**
**输入样例**：
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
**输出样例**：
8

**解题思路：**

由题意可知，所有边的权值都为1，可以用宽度优先搜索找到最短路径，由于宽度优先搜索的性质，最先被搜索的点一定是最短路径的点。

**解题代码：**

```cpp
#include<iostream>
#include<cstring>

using namespace std;

const int N = 110;

typedef pair<int,int> PII;

int n,m;
int g[N][N]; //存储地图
int d[N][N]; // 存储每一个位置到初始点的距离
PII q[N*N];  //宽度优先遍历的队列

int bfs()
{
    memset(d,-1,sizeof d); //初始化，-1代表这个点没有没遍历过
    d[0][0] = 0; //第一个点到自己的距离是0
    int hh=0;tt=-1; //初始化队列
    q[++tt] = {0,0}; //从第一个点开始
    
    int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1}; //方向向量，用于计算一个点的上下左右的临点
    
    while(hh<=tt) //宽度优先遍历
    {
        auto t = q[hh++];
        for(int i=0;i<4;i++) //遍历四个方向
        {
            int x = dx[i]+t.first, y = dy[i]+t.second;
            if(x>=0&&x<n&&y>=0&&y<n&&g[x][y]==0&&d[x][y]==-1) //当某一个方向符合条件时
            {
                d[x][y] = d[t.first][t.second] + 1; //更新距离
                q[++tt] = {x, y}; //加入队列
            }
        }
    }
    return d[n-1][m-1]; //d的最后一个点的位置存的数就是最终结果
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>g[i][j];
    
    cout<<bfs()<<endl;
}
```



------

> Author: Trafal
>
> Date: 2020.11.1
>
> Editor: Typora	

