# 构建基本脚本

## 使用多个命令

shell 脚本的关键在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给 另一个命令。shell 可以让你将多个命令串起来，一次执行完成。如果要两个命令一起运行，可以 把它们放在同一行中，彼此间用分号隔开。

这种技术对于小型脚本尚可，但它有一个很大的缺陷：每次运行之前，你都必须在命令提示 符下输入整个命令。可以将这些命令组合成一个简单的文本文件，这样就不需要在命令行中手动 输入了。在需要运行这些命令时，只用运行这个文本文件就行了。

## 创建 shell 脚本文件

在创建 shell 脚本文件时，必须在文件的第一行指定要使用的 shell。其格式为：

```bash
#!/bin/bash
```

在通常的 shell 脚本中，井号（#）用作注释行。shell 并不会处理 shell 脚本中的注释行。然而， shell 脚本文件的第一行是个例外，#后面的惊叹号会告诉 shell 用哪个 shell 来运行脚本（是的，你 可以使用 bash shell，同时还可以使用另一个 shell 来运行你的脚本）。

可以根据需要，使用分号将两个命令放在一行上，但在 shell 脚本 中，你可以在独立的行中书写命令。shell 会按根据命令在文件中出现的顺序进行处理。

在运行新脚本前，还要做其他一些事。

shell 会通过 PATH 环境变量来查找命令。快速查看一下 PATH 环境变量就可以弄清问题所在。

```bash
echo $PATH
```

PATH 环境变量被设置成只在一组目录中查找命令。要让 shell 找到 test1 脚本，只需采取以下两种作法之一：

- 将 shell 脚本文件所处的目录添加到 PATH 环境变量中；

* 在提示符中用绝对或相对文件路径来引用 shell 脚本文件。

> 有些 Linux 发行版将\$HOME/bin 目录添加进了 PATH 环境变量。它在每个用户的 HOME 目录 下提供了一个存放文件的地方，shell 可以在那里查找要执行的命令。

在创建文件时，umask 的值决定了新文件的默认权限设置。由于 umask 变量在 Ubuntu 中 被设成了 022，所以系统创建的文件只有文件属主和属组才有读/写权限。

下一步是通过 chmod 命令赋予文件属主执行文件的权限

```bash
chmod u+x test1
```

## 显示消息

大多数 shell 命令都会产生自己的输出，这些输出会显示在脚本所运行的控制台显示器上。很 多时候，你可能想要添加自己的文本消息来告诉脚本用户脚本正在做什么。可以通过 echo 命令 来实现这一点。如果在 echo 命令后面加上了一个字符串，该命令就能显示出这个文本字符串。

```bash
echo This is a test
```

注意，默认情况下，不需要使用引号将要显示的文本字符串划定出来。但有时在字符串中出现引号的话就比较麻烦了。

echo 命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，你需要在 文本中使用其中一种引号，而用另外一种来将字符串划定起来。

```bash
echo "This is a test to see if you're paying attention"
```

但如果想把文本字符串和命令输出显示在同一行中，该怎么办呢？可以用 echo 语句 的-n 参数。

```bash
echo -n "The time and date are: "
```

你需要在字符串的两侧使用引号，保证要显示的字符串尾部有一个空格。命令输出将会在紧 接着字符串结束的地方出现。

---

## 使用变量

变量允许你临时性地将信息存储在 shell 脚本中， 以便和脚本中的其他命令一起使用。

### 环境变量

shell 维护着一组环境变量，用来记录特定的系统信息。比如系统的名称、登录到系统上的用 户名、用户的系统 ID（也称为 UID）、用户的默认主目录以及 shell 查找程序的搜索路径。可以用 set 命令来显示一份完整的当前环境变量列表。

在脚本中，你可以在环境变量名称之前加上美元符（\$）来使用这些环境变量。

```bash
#!/bin/bash
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME
```

$USER、$UID 和\$HOME 环境变量用来显示已登录用户的有关信息。

注意，echo 命令中的环境变量会在脚本运行时替换成当前值。另外，在第一个字符串中可 以将\$USER 系统变量放置到双引号中，而 shell 依然能够知道我们的意图。但采用这种方法也有一 个问题。

```bash
echo "The cost of the item is $15"
```

只要脚本在引号中出现美元符，它就会以为你在引用一个变量。在 这个例子中，脚本会尝试显示变量\$1（但并未定义），再显示数字 5。要显示美元符，你必须在它 前面放置一个反斜线。

```bash
echo "The cost of the item is \$15"
```

反斜线允许 shell 脚本将美元符解读为实际的美元符，而不是变量。

> 你可能还见过通过\${variable}形式引用的变量。变量名两侧额外的花括号通常用来帮 助识别美元符后的变量名。

### 用户变量

除了环境变量，shell 脚本还允许在脚本中定义和使用自己的变量。定义变量允许临时存储数 据并在整个脚本中使用，从而使 shell 脚本看起来更像一个真正的计算机程序。

用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过 20 个。用户变量 区分大小写，所以变量 Var1 和变量 var1 是不同的。

使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格（另一个困扰初学者的用 法）。这里有一些给用户变量赋值的例子。

```bash
var1=10
var2=-57
var3=testing
var4="still more testing"
```

shell 脚本会自动决定变量值的数据类型。在脚本的整个生命周期里，shell 脚本中定义的变量 会一直保持着它们的值，但在 shell 脚本结束时会被删除掉。

与系统变量类似，用户变量可通过美元符引用。

```bash
days=10
guest="Katie"
echo "$guest checked in $days days ago"
days=5
guest="Jessica"
echo "$guest checked in $days days ago"
```

变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使 用美元符，而引用变量来对其进行赋值时则不要使用美元符。

### 命令替换

shell 脚本中有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。把输出赋 给变量之后，就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。

有两种方法可以将命令输出赋给变量：

- 反引号字符（`）
- \$()格式

命令替换允许你将 shell 命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编 程中的一个主要组成部分。

要么用一对反引号把整个命令行命令围起来：

```bash
testing=`date`
```

要么使用\$()格式：

```bash
testing=$(date)
```

shell 会运行命令替换符号中的命令，并将其输出赋给变量 testing。注意，赋值等号和命令 替换字符之间没有空格。

下面这个例子很常见，它在脚本中通过命令替换获得当前日期并用它来生成唯一文件名。

```bash
#!/bin/bash
# copy the /usr/bin directory listing to a log file
today=$(date +%y%m%d)
ls /usr/bin -al > log.$today
```

today 变量是被赋予格式化后的 date 命令的输出。这是提取日期信息来生成日志文件名常用 的一种技术。+%y%m%d 格式告诉 date 命令将日期显示为两位数的年月日的组合。

这个脚本将日期值赋给一个变量，之后再将其作为文件名的一部分。文件自身含有目录列表 的重定向输出。

目录中出现的日志文件采用\$today 变量的值作为文件名的一部分。日志文件的内容是 /usr/bin 目录内容的列表输出。

> 命令替换会创建一个子 shell 来运行对应的命令。子 shell（subshell）是由运行该脚本的 shell 所创建出来的一个独立的子 shell（child shell）。正因如此，由该子 shell 所执行命令是无法 使用脚本中所创建的变量的。  
> 在命令行提示符下使用路径./运行命令的话，也会创建出子 shell；要是运行命令的时候 不加入路径，就不会创建子 shell。如果你使用的是内建的 shell 命令，并不会涉及子 shell。 在命令行提示符下运行脚本时一定要留心！

## 重定向输入和输出

有些时候你想要保存某个命令的输出而不仅仅只是让它显示在显示器上。bash shell 提供了几 个操作符，可以将命令的输出重定向到另一个位置（比如文件）。重定向可以用于输入，也可以 用于输出，可以将文件重定向到命令输入。

### 输出重定向

基本的重定向将命令的输出发送到一个文件中。bash shell 用大于号（>）来完成这项功能：

```bash
command > outputfile
```

之前显示器上出现的命令输出会被保存到指定的输出文件中。

如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。

可以用双大于号（>>）来追加数据。

### 输入重定向

输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令，而非将命令的 输出重定向到文件。

输入重定向符号是小于号（<）：

```bash
wc < test6
```

wc 命令可以对对数据中的文本进行计数。默认情况下，它会输出 3 个值：

- 文本的行数
- 文本的词数
- 文本的字节数

通过将文本文件重定向到 wc 命令，你立刻就可以得到文件中的行、词和字节的计数。

还有另外一种输入重定向的方法，称为内联输入重定向（inline input redirection）。这种方法 无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。

内联输入重定向符号是远小于号（<<）。除了这个符号，你必须指定一个文本标记来划分输 入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致。

```bash
command << mark
data
mark
```

```bash
wc << EOF
> test string 1
> test string 2
> EOF
```

次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串。

---

## 管道

有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现，只是有些笨拙。

```bash
rpm -qa > rpm.list
sort < rpm.list
```

通过标准输出重定向，rpm 命令的输出被重定向到了文件 rpm.list。命令完成后，rpm.list 保存 着系统中所有已安装的软件包列表。接下来，输入重定向将 rpm.list 文件的内容发送给 sort 命令， 该命令按字母顺序对软件包名称进行排序。

我们用不着将命令输出重定向 到文件中，可以将其直接重定向到另一个命令。这个过程叫作管道连接（piping）。

管道被放在命令之间，将一个命令的输出重定向 到另一个命令中：

```
command1 | command2
```

Linux 系统实际上会同时运行这两个命令，在 系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据 传输不会用到任何中间文件或缓冲区。

现在，可以利用管道将 rpm 命令的输出送入 sort 命令来产生结果。

```bash
rpm -qa | sort
```

可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细 化操作。

在这个例子中，sort 命令的输出会一闪而过，所以可以用一条文本分页命令（例如 less 或 more）来强行将输出按屏显示。

```bash
rpm -qa | sort | more
```

到目前为止，管道流行的用法之一是将命令产生的大量输出通过管道传送给 more 命令。 这对 ls 命令来说尤为常见

---

## 执行数学运算

在 shell 脚本中有两种途径来进行数学运算。

### expr 命令

expr 命令允许在命令行 上处理数学表达式，但是特别笨拙。

```bash
expr 1 + 5
```

expr 命令能够识别少数的数学和字符串操作符

### 使用方括号

在 bash 中，在将一个数学运算结果赋给某个变量时，可以用美元符和 方括号（\$[ operation ]）将数学表达式围起来。

```bash
var1=$[1 + 5]
echo $var1
```

用方括号执行 shell 数学运算比用 expr 命令方便很多。这种技术也适用于 shell 脚本。

同样，注意在使用方括号来计算公式时，不用担心 shell 会误解乘号或其他符号。shell 知道它不是通配符，因为它在方括号内。

bash shell 数学运算符只支持整数运算。若要进行任何实际的数学计算，这是一个巨大的限制。

> z shell（zsh）提供了完整的浮点数算术操作。如果需要在 shell 脚本中进行浮点数运算，可 以考虑看看 z shell

### 浮点解决方案

有几种解决方案能够克服 bash 中数学运算的整数限制。常见的方案是用内建的 bash 计算器， 叫作 bc。

**bc 的基本用法**

bash 计算器实际上是一种编程语言，它允许在命令行中输入浮点表达式，然后解释并计算该 表达式，后返回结果。bash 计算器能够识别：

- 数字（整数和浮点数）
- 变量（简单变量和数组）
- 注释（以#或 C 语言中的/\* \*/开始的行）
- 表达式
- 编程语句（例如 if-then 语句）
- 函数

可以在 shell 提示符下通过 bc 命令访问 bash 计算器：

```bash
bc
```

要退出 bash 计算器，你必须输入 quit。

浮点运算是由内建变量 scale 控制的。必须将这个值设置为你希望在计算结果中保留的小数 位数，否则无法得到期望的结果。

scale 变量的默认值是 0。在 scale 值被设置前，bash 计算器的计算结果不包含小数位。在将 其值设置成 4 后，bash 计算器显示的结果包含四位小数。-q 命令行选项可以不显示 bash 计算器冗 长的欢迎信息。

除了普通数字，bash 计算器还能支持变量。

```bash
bc -q
var1=10
var1*4
print var1
```

变量一旦被定义，你就可以在整个 bash 计算器会话中使用该变量了。print 语句允许你打印 变量和数字。

**在脚本中使用 bc**

现在你可能想问 bash 计算器是如何在 shell 脚本中帮助处理浮点运算的。还记得命令替换吗？ 是的，可以用命令替换运行 bc 命令，并将输出赋给一个变量。基本格式如下：

```bash
variable=$(echo "options; expression" | bc)
```

第一部分 options 允许你设置变量。如果你需要不止一个变量，可以用分号将其分开。 expression 参数定义了通过 bc 执行的数学表达式。这里有个在脚本中这么做的例子。

```bash
#!/bin/bash
var1=$(echo "scale=4; 3.44 / 5" | bc)
echo The answer is $var1
```

这个例子将 scale 变量设置成了四位小数，并在 expression 部分指定了特定的运算。

```bash
#!/bin/bash
var1=100
var2=45
var3=$(echo "scale=4; $var1 / $var2" | bc)
echo The answer for this is $var3
```

这个方法适用于较短的运算，但有时你会涉及更多的数字。如果需要进行大量运算，在一个 命令行中列出多个表达式就会有点麻烦。

有一个方法可以解决这个问题。bc 命令能识别输入重定向，允许你将一个文件重定向到 bc 命令来处理。但这同样会叫人头疼，因为你还得将表达式存放到文件中。

好的办法是使用内联输入重定向，它允许你直接在命令行中重定向数据。在 shell 脚本中， 你可以将输出赋给一个变量。

```bash
variable=$(bc << EOF
options
statements
experssions
EOF
)
```

EOF 文本字符串标识了内联重定向数据的起止。记住，仍然需要命令替换符号将 bc 命令的输 出赋给变量。

现在可以将所有 bash 计算器涉及的部分都放到同一个脚本文件的不同行。

在 bash 计算器中创建的变量只在 bash 计算器中有效，不能在 shell 脚本中使用。

---

## 退出脚本

shell 中运行的每个命令都使用退出状态码（exit status）告诉 shell 它已经运行完毕。退出状态 码是一个 0 ～ 255 的整数值，在命令结束运行时由命令传给 shell。可以捕获这个值并在脚本中使用。

### 查看退出状态码

Linux 提供了一个专门的变量$?来保存上个已执行命令的退出状态码。对于需要进行检查的 命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由 shell 所执行的后一条命令 的退出状态码。

按照惯例，一个成功结束的命令的退出状态码是 0。如果一个命令结束时有错误，退出状态码就是一个正数值。

无效命令会返回一个退出状态码 127。

退出状态码 126 表明用户没有执行命令的正确权限。

另一个会碰到的常见错误是给某个命令提供了无效参数。 这会产生一般性的退出状态码 1，表明在命令中发生了未知错误。

### exit 命令

默认情况下，shell 脚本会以脚本中的后一个命令的退出状态码退出。

你可以改变这种默认行为，返回自己的退出状态码。exit 命令允许你在脚本结束时指定一 个退出状态码。

```bash
#!/bin/bash
...
exit 5
```

也可以在 exit 命令的参数中使用变量。

```bash
#!/bin/bash
var1=9
...
exit var1
```

你要注意这个功能，因为退出状态码大只能是 255。
最终的结果是指定的数值除以 256 后得到的余数。
