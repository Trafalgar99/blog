# 呈现数据

## 理解输入和输出

### 标准文件描述符

Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用文件描述符（file descriptor）来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开 的文件。每个进程一次多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文 件描述符（0、1和2）

| 文件描述符 | 缩写   | 描述     |
| ---------- | ------ | -------- |
| 0          | STDIN  | 标准输入 |
| 1          | STDOUT | 标准输出 |
| 2          | STDERR | 标准错误 |


这三个特殊文件描述符会处理脚本的输入和输出。shell用它们将shell默认的输入和输出导向 到相应的位置。

**STDIN**

STDIN文件描述符代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN 文件描述符对应的键盘获得输入，在用户输入时处理每个字符

在使用输入重定向符号（<）时，Linux会用重定向指定的文件来替换标准输入文件描述符。 它会读取文件并提取数据，就如同它是键盘上键入的。 

许多bash命令能接受STDIN的输入，尤其是没有在命令行上指定文件的话。

```bash
cat
```

当在命令行上只输入cat命令时，它会从STDIN接受输入。输入一行，cat命令就会显示出 一行。 

但你也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入。 
```bash
cat < testfile
```

现在cat命令会用testfile文件中的行作为输入。你可以使用这种技术将数据输入到任何能从 STDIN接受数据的shell命令中。 

**STDOUT**

STDOUT文件描述符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell 的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。 

默认情况下，大多数bash命令会将输出导向STDOUT文件描述符。
可以 用输出重定向来改变。 
```bash
ls -l > test2 
```

通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。
你也可以将数据追加到某个文件。这可以用>>符号来完成。 

但是，如果你对脚本使用了标准输出重定向，你会遇到一个问题。
```bash
$ ls -al badfile > test3 
ls: cannot access badfile: No such file or directory 
```

当命令生成错误消息时，shell并未将错误消息重定向到输出重定向文件。shell创建了输出重 定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错 误。test3文件创建成功了，只是里面是空的。

shell对于错误消息的处理是跟普通输出分开的。如果你创建了在后台模式下运行的shell脚 本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些 信息是不会出现在日志文件中的。你需要换种方法来处理。 

**STDERR**

shell通过特殊的STDERR文件描述符来处理错误消息。STDERR文件描述符代表shell的标准错 误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。 

默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方（尽管分配给它们 的文件描述符值不同）。也就是说，默认情况下，错误消息也会输出到显示器输出中。 

但从上面的例子可以看出，STDERR并不会随着STDOUT的重定向而发生改变。使用脚本时， 你常常会想改变这种行为，尤其是当你希望将错误消息保存到日志文件中的时候。 

### 重定向错误

**只重定向错误**

STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文 件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。 
```bash
ls -al badfile 2> test4 
```

现在运行该命令，错误消息不会出现在屏幕上了。该命令生成的任何错误消息都会保存在输 出文件中。用这种方法，shell会只重定向错误消息，而非普通数据。

**重定向错误和数据**

如果想重定向错误和正常输出，必须用两个重定向符号。需要在符号前面放上待重定向数据 所对应的文件描述符，然后指向用于保存数据的输出文件。

```bash
ls -al test test2 test3 badtest 2> test6 1> test7 
```

shell利用1>符号将ls命令的正常输出重定向到了test7文件，而这些输出本该是进入STDOUT 的。所有本该输出到STDERR的错误消息通过2>符号被重定向到了test6文件。 

可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来。这样就可以轻松地识别 出错误信息

另外，如果愿意，也可以将STDERR和STDOUT的输出重定向到同一个输出文件。为此bash shell 提供了特殊的重定向符号&>。 
```bash
ls -al test test2 test3 badtest &> test7 
```

当使用&>符时，命令生成的所有输出都会发送到同一位置，包括数据和错误。你会注意到其 中一条错误消息出现的位置和预想中的不一样。badtest文件（列出的后一个文件）的这条错误 消息出现在输出文件中的第二行。为了避免错误信息散落在输出文件中，相较于标准输出，bash shell自动赋予了错误消息更高的优先级。这样你能够集中浏览错误信息了。 

## 在脚本中重定向输出

可以在脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相 应的文件描述符就行了。有两种方法来在脚本中重定向输出： 

+ 临时重定向行输出 
+ 永久重定向脚本中的所有命令 

### 临时重定向

如果有意在脚本中生成错误消息，可以将单独的一行输出重定向到STDERR。你所需要做的 是使用输出重定向符来将输出信息重定向到STDERR文件描述符。在重定向到文件描述符时，你 必须在文件描述符数字之前加一个&： 
```bash
echo "This is an error message" >&2 
```
这行会在脚本的STDERR文件描述符所指向的位置显示文本，而不是通常的STDOUT。

```bash
echo "This is an error" >&2 
echo "This is normal output" 
```
默认情况下，Linux会将STDERR导向STDOUT。但是，如果你在运行脚本时重定向了 STDERR，脚本中所有导向STDERR的文本都会被重定向。 

### 永久重定向

如果脚本中有大量数据需要重定向，那重定向每个echo语句就会很烦琐。取而代之，你可 以用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。 

```bash
exec 1>testout 

echo "This is a test of redirecting all output" 
echo "from a script to another file." 
echo "without having to redirect every individual line" 
```

exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所 有输出会被重定向到文件。 

可以在脚本执行过程中重定向STDOUT。 
```bash
exec 2>testerror 

echo "This is the start of the script" 
echo "now redirecting all output to another location" 

exec 1>testout 

echo "This output should go to the testout file" 
echo "but this should go to the testerror file" >&2 
```
这个脚本用exec命令来将发给STDERR的输出重定向到文件testerror。接下来，脚本用 echo语句向STDOUT显示了几行文本。随后再次使用exec命令来将STDOUT重定向到testout文 件。注意，尽管STDOUT被重定向了，但你仍然可以将echo语句的输出发给STDERR，在本例中还 是重定向到testerror文件。 

## 在脚本中重定向输入

可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他 位置。exec命令允许你将STDIN重定向到Linux系统上的文件中： 
```bash
exec 0< testfile
```

这个命令会告诉shell它应该从文件testfile中获得输入，而不是STDIN。这个重定向只要 在脚本需要输入时就会作用。下面是该用法的实例。 
```bash
exec 0< testfile 
count=1 

while read line
do
    echo "Line #$count: $line" 
    count=$[ $count + 1 ] 
done
```
将STDIN重定向到文件后， 当read命令试图从STDIN读入数据时，它会到文件去取数据，而不是键盘。 

这是在脚本中从待处理的文件中读取数据的绝妙办法

## 创建自己的重定向

在脚本中重定向输入和输出时，并不局限于这3个默认的文件描述符。我曾提到过，在shell 中多可以有9个打开的文件描述符。其他6个从3~8的文件描述符均可用作输入或输出重定向。 你可以将这些文件描述符中的任意一个分配给文件，然后在脚本中使用它们。

### 创建输出文件描述符

可以用exec命令来给输出分配文件描述符。和标准的文件描述符一样，一旦将另一个文件 描述符分配给一个文件，这个重定向就会一直有效，直到你重新分配。

```bash
exec 3>test13out 

echo "This should display on the monitor" 
echo "and this should be stored in the file" >&3 
echo "Then this should be back on the monitor" 
```

这个脚本用exec命令将文件描述符3重定向到另一个文件。当脚本执行echo语句时，输出内 容会像预想中那样显示在STDOUT上。但你重定向到文件描述符3的那行echo语句的输出却进入 了另一个文件。这样你就可以在显示器上保持正常的输出，而将特定信息重定向到文件中（比如 日志文件）。 

也可以不用创建新文件，而是使用exec命令来将输出追加到现有文件中。 
```bash
exec 3>>test13out
```

现在输出会被追加到test13out文件，而不是创建一个新文件。 

### 重定向文件描述符

你可以分配另外一个文件描述符给标准文件描述 符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用 该文件描述符重定向回STDOUT。

```bash
exec 3>&1
exec 1>test14out 

echo "This should store in the output file" 
echo "along with this line." 

exec 1>&3 
echo "Now things should be back to normal" 
```

首先，脚本将文件描述符3重定向到文件描述符1 的当前位置，也就是STDOUT。这意味着任何发送给文件描述符3的输出都将出现在显示器上。 

第二个exec命令将STDOUT重定向到文件，shell现在会将发送给STDOUT的输出直接重定向到 输出文件中。但是，文件描述符3仍然指向STDOUT原来的位置，也就是显示器。如果此时将输出 数据发送给文件描述符3，它仍然会出现在显示器上，尽管STDOUT已经被重定向了。 

在向STDOUT（现在指向一个文件）发送一些输出之后，脚本将STDOUT重定向到文件描述符 3的当前位置（现在仍然是显示器）。这意味着现在STDOUT又指向了它原来的位置：显示器。 

### 创建输入文件描述符

可以用和重定向输出文件描述符同样的办法重定向输入文件描述符。在重定向到文件之前， 先将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它 原来的位置。 

```bash
exec 6<&0 

exec 0< testfile 

count=1 
while read line
do
    echo "Line #$count: $line" 
    count=$[ $count + 1 ] 
done
exec 0<&6 
read -p "Are you done now? " answer 
case $answer in 
Y|y) echo "Goodbye";; 
N|n) echo "Sorry, this is the end.";; 
esac 
```

文件描述符6用来保存STDIN的位置。然后脚本将STDIN重定向到一个文件。 read命令的所有输入都来自重定向后的STDIN（也就是输入文件）。 

在读取了所有行之后，脚本会将STDIN重定向到文件描述符6，从而将STDIN恢复到原先的 位置。该脚本用了另外一个read命令来测试STDIN是否恢复正常了。这次它会等待键盘的输入。

