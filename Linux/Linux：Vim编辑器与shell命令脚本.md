# Vim 编辑器与 Shell 命令脚本 

> Vim 文本编辑器;
> 编写 Shell 脚本;
> 流程控制语句;
> 计划任务服务程序;

---------------------------------
## Vim文本编辑器
> Vim 编辑器中设置了三种模式—命令 模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工 作效率，而且用户在习惯之后也会觉得相当顺手

模式|功能
-|-
命令模式|控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。 
输入模式|正常的文本录入。 
末行模式|保存或退出文档，以及设置编辑环境。 

*在每次运行 Vim 编辑器时，默认进入命令模式，此时需要先切换到输入模式后再进行文 档编写工作，而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档 的保存或退出操作。在 Vim 中，无法直接从输入模式切换到末行模式。*

命令|作用
-|-
dd| 删除（剪切）光标所在整行 
5dd| 删除（剪切）从光标处开始的 5 行 
yy| 复制光标所在整行 
5yy| 复制从光标处开始的 5 行 
n| 显示搜索命令定位到的下一个字符串 
N| 显示搜索命令定位到的上一个字符串 
u| 撤销上一步的操作 
p| 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 

末行模式中可用的命令 
命令|作用
-|-
:w| 保存 
:q| 退出 
:q!| 强制退出（放弃对文档的修改内容） 
:wq!| 强制保存退出 
:set nu| 显示行号 
:set nonu| 不显示行号 
:命令| 执行该命令 
:整数| 跳转到该行 
:s/one/two| 将当前光标所在行的第一个 one 替换成 two 
:s/one/two/g| 将当前光标所在行的所有 one 替换成 two 
:%s/one/two/g| 将全文中的所有 one 替换成 two 
?字符串| 在文本中从下至上搜索该字符串 
/字符串| 在文本中从上至下搜索该字符串 

-------------------------

## 编写shell脚本
> 可以将 Shell 终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与 Linux 系 统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程 语言才有的控制结构特性。要想正确使用 Shell 中的这些功能特性，准确下达命令尤为重要。 Shell 脚本命令的工作方式有两种：交互式和批处理。 
> 交互式（Interactive）：用户每输入一条命令就立即执行。 
> 批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本 中诸多的命令。 

Shell 脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以 表示是一个脚本文件
 

 **接受用户的参数**
 > Linux 系统中的 Shell 脚本语言已经内设了用于接收参数的变量，变量之间可以使用空格间隔。例如$0 对应的是当前 Shell 脚本程序的名称，$#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、 $2、$3……则分别对应着第 N 个位置的参数值
 ```shell
 echo "当前脚本名称为$0" 
 echo "总共有$#个参数，分别是$*。" 
 echo "第 1 个参数为$1，第 5 个为$5" 

 sh example.sh one two three four five six 
-----------------------------------
 当前脚本名称为 example.sh 总共有 6 个参数，分别是 one two three four five six。 第 1 个参数为 one，第 5 个为 five。 
 ```

 **判断用户的参数**
 > Shell 脚本中的条 件测试语法可以判断表达式是否成立，若条件成立则返回数字 0，否则便返回其他随机数值。 条件测试语法的执行格式如图 4-16 所示。切记，条件表达式两边均应有一个空格。 
 
 按照测试对象来划分，条件测试语句可以分为 4 种： 
 + 文件测试语句； 
 + 逻辑测试语句； 
 + 整数值比较语句； 
 + 字符串比较语句。 

*文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符*

运算符|作用
-|-
-d| 测试文件是否为目录类型 
-e| 测试文件是否存在 
-f| 判断是否为一般文件 
-r| 测试当前用户是否有权限读取 
-w| 测试当前用户是否有权限写入 
-x| 测试当前用户是否有权限执行 
```shell
[ -d /etc/fstab ]
echo $?
--------------------------------
1
```
*逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在 Shell 终端中逻辑“与”的运算符号是&&，它表示当前面的命令执行成功后才会执行它后面的命令*
```shell
[ -e /dev/cdrom ] && echo "Exist"
---------------------------------
Exist 

[ $USER = root ] || echo "user" 

[ ! $USER = root ] || echo "administrator" 
```
例子:
下面这个示例的执行顺序是，先判断当前 登录用户的 USER 变量名称是否等于 root，然后用逻辑运算符“非”进行取反操作，效果就 变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运 算符输出 user 字样；或条件不满足则会通过逻辑“或”运算符输出 root 字样，而如果前面的 &&不成立才会执行后面的||符号。 
```shell
[ ! $USER = root ] && echo "user" || echo "root" 
```

----------------
**可用的整数比较运算符 **
> 整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且 不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲 突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规 范的整数比较运算符来进行操作

运算符|作用
-|-
-eq| 是否等于 
-ne| 是否不等于 
-gt| 是否大于 
-lt| 是否小于 
-le| 是否等于或小于 
-ge| 是否大于或等于 
```shell
[ 10 -gt 10 ] 
echo $? 
```

例子：

先使用 free -m 命令查看内存使用量情况（单位为 MB），然后通过 grep Mem:命令过滤 出剩余内存量的行，再用 awk '{print $4}'命令只保留第四列，最后用 FreeMem=`语句`的方式 把语句内执行的结果赋值给变量。 
```shell
FreeMem=`free -m | grep Mem: | awk '{print $4}'` 
echo $FreeMem 
[ $FreeMem -lt 1024 ] && echo "Insufficient Memory" 
```

字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来 判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。
运算符|作用
-|-
=| 比较字符串内容是否相同 
!=| 比较字符串内容是否不同 
-z| 判断字符串内容是否为空 
```shell
[ -z $String] 
echo $?

[ $LANG != "en.US" ] && echo "Not en.US" 
```
------------------------------------

**if 条件测试语句**
> if 条件语句的单分支结构由 if、then、fi 关键词组成，而且只在条件成立后才执行预设的 命令

下面使用单分支的 if 条件语句来判断/media/cdrom 文件是否存在，若存在就结束条件判 断和整个 Shell 脚本，反之则去创建这个目录： 
```shell
vim mkcdrom.sh 
#!/bin/bash 
DIR="/media/cdrom" 
if [ ! -e $DIR ] 
then 
mkdir -p $DIR 
fi
```

下面使用双分支的 if 条件语句来验证某台主机是否在线，然后根据返回值的结果，要么 显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用 ping 命令来测试与对方 主机的网络联通性，而 Linux 系统中的 ping 命令不像 Windows 一样尝试 4 次就结束，因此为 了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据 包的发送间隔，以及使用-W 参数定义等待超时时间。 
```shell
vim chkhost.sh 
#!/bin/bash 
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null 
if [ $? -eq 0 ] 
then echo "Host $1 is On-line." 
else 
echo "Host $1 is Off-line." 
fi
```

下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如 Excellent、Pass、Fail 等提示信息。在 Linux 系统中，read 是用来读取用户输入信息的命令， 能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一定的提示信 息。在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分，才输出 Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分 且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了）， 则输出 Fail 字样：
```shell
#!/bin/bash read -p "Enter your score（0-100）： " GRADE 
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then 
echo "$GRADE is Excellent" 
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then 
echo "$GRADE is Pass" 
else 
echo "$GRADE is Fail"  
fi
```

**for 条件循环语句**
> for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理

下面使用 for 循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设 置密码:
```shell
#!/bin/bash 
read -p "Enter The Users Password : " PASSWD 
for UNAME in `cat users.txt` 
do 
id $UNAME &> /dev/null 
if [ $? -eq 0 ] 
then 
echo "Already exists" 
else 
useradd $UNAME &> /dev/null 
echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null 
if [ $? -eq 0 ] 
then 
echo "$UNAME , Create success" 
else 
echo "$UNAME , Create failure" 
fi 
fi 
done 
```

**while 条件循环语句**
> while 条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往 往在执行前并不确定最终执行的次数，完全不同于 for 循环语句中有目标、有范围的使用场 景。while 循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执 行，为假就结束循环。

该脚本使用$RANDOM 变量来调取出一个随机的数值（范围为 0～32767）， 将这个随机数对 1000 进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read 命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、 大于还是小于使用 expr 命令取得的数值。
```shell
#!/bin/bash 
PRICE=$(expr $RANDOM % 1000) 
TIMES=0 
echo "商品实际价格为 0-999 之间，猜猜看是多少？" 
while true 
do 
read -p "请输入您猜测的价格数目：" INT 
let TIMES++ 
if [ $INT -eq $PRICE ] ; then 
echo "恭喜您答对了，实际价格是 $PRICE" 
echo "您总共猜 g $TIMES 次" 
exit 0 
elif [ $INT -gt $PRICE ] ; then 
echo "太高了！" 
else 
echo "太低了！" 
fi 
done
```

-----------------------------
**case 条件测试语句**
> case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹配 数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内， 则会去执行星号（*）中所定义的默认命令

提示用户输入一个字符并将其赋值给变量 KEY， 然后根据变量 KEY 的值向用户显示其值是字母、数字还是其他字符。 
```shell
#!/bin/bash 
read -p "请输入一个字符，并按 Enter 键确认：" KEY 
case "$KEY" in 
[a-z]|[A-Z]) 
echo "您输入的是 字母。" 
;; 
[0-9]) 
echo "您输入的是 数字。" 
;; 
*) 
echo "您输入的是 空格、功能键或其他控制字符。" 
esac
```

**计划任务服务程序 **
> 计划任务分为一次性计划任务与长期性计划任务

顾名思义，一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用 at 命令实现这种功能，只需要写成“at 时间”的形式就可以。如果想要查看已设置好但还未执行的一次性计划任务，可以使用“at -l”命令；要想将其删除，可以用“atrm 任务序号”。在使用at 命令来设置一次性计划任务时，默认采用的是交互式方法

例如，使用下述命令将系 统设置为在今晚 23:30 分自动重启网站服务。 
```shell
# at 23:30 
at > systemctl restart httpd 
at > 此处请同时按下 Ctrl + D 组合键来结束编写计划任务 
job 3 at Mon Apr 27 23:30:00 2017 
# at -l 
3 Mon Apr 27 23:30:00 2017 a root 
```

可以把前面学习的管道符（任意门） 放到两条命令之间，让 at 命令接收前面 echo 命令的输出信息，以达到通过非交互式的方式创 建计划一次性任务的目的。 
```shell
# echo "systemctl restart httpd" | at 23:30 
job 4 at Mon Apr 27 23:30:00 2017 
# at -l 
3 Mon Apr 27 23:30:00 2017 a root 
4 Mon Apr 27 23:30:00 2017 a root 
```

如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个： 
```shell
atrm 3 
```

如果我们希望 Linux 系统能够周期性地、有规律地执行某些具体的任务，那么 Linux 系统 中默认启用的 crond 服务简直再适合不过了。创建、编辑计划任务的命令为“crontab -e”，查看 当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab -r”。另外，如果您是 以管理员的身份登录的系统，还可以在 crontab 命令中加上-u参数来编辑他人的计划任务。 

“分、时、日、月、星期 命令”。 这是使用 crond 服务设置任务的参数格式
需要注意的是，如果有些字段 没有设置，则需要使用星号（*）占位

字段|说明
-|-
分| 取值为 0～59 的整数 
时| 取值为 0～23 的任意整数 
日| 取值为 1～31 的任意整数 
月| 取值为 1～12 的任意整数 
星期| 取值为 0～7 的任意整数，其中 0 与 7 均为星期日 
命令| 要执行的命令或程序脚本 

例子：
假设在每周一、三、五的凌晨 3 点 25 分，都需要使用 tar 命令把某个网站的数据目录进 行打包处理，使其作为一个备份文件。我们可以使用 crontab -e 命令来创建计划任务。为自己 创建计划任务无需使用-u 参数，具体的实现效果的参数如 crontab -l 命令结果所示： 
 
```shell
# crontab -e 
no crontab for root - using an empty one 
crontab: installing new crontab
# crontab -l 
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot 
```
需要说明的是，除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示 8 月、9 月 和 12 月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”， 则表示每月的 12～15 日）。以及用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔 2 分钟执行一次任务）

例子：
如果在 crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再 添加一条计划任务，它的功能是每周一至周五的凌晨 1点钟自动清空/tmp目录内的所有文件。尤 其需要注意的是，在 crond 服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如 果不知道绝对路径，请用 whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。 
 
 ```shell
 # crontab -e
 crontab: installing new crontab 
 # crontab -l 
 25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot 
 0 1 * * 1-5 /usr/bin/rm -rf /tmp/*
 ```


 -------------------------------------
> 感谢刘遄老师提供的开源优秀教材《Linux就该这么学》www.linuxprobe.com  