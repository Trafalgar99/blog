# 第三章 管道符、重定向与环境变量

### 1、输入输出重定向 
> 输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到 屏幕的数据信息写入到指定文件中。又将输出重定向分为了标准输出重定向和错误输出重定向两种 不同的技术，以及清空写入与追加写入两种模式。

+ 标准输入重定向（STDIN，文件描述符为 0）：默认从键盘输入，也可从其他文件或命 令中输入。 
+ 标准输出重定向（STDOUT，文件描述符为 1）：默认输出到屏幕。 
+ 错误输出重定向（STDERR，文件描述符为 2）：默认输出到屏幕。 
比如我们分别查看两个文件的属性信息，其中第二个文件是不存在的，虽然针对这两个 文件的操作都分别会在屏幕上输出一些数据信息，但这两个操作的差异其实很大
```
touch file1.txt
ll file1.txt    查看存在的文件--输出正确信息
ll ffffff.ff    查看不存在的文件--输出错误提示信息
```
**输入重定向中用到的符号及其作用:**
符号 | 作用
-|-
命令 < 文件 |命令 < 文件 
命令 << 分界符 |从标准输入中读入，直到遇见分界符才停止
命令 < 文件 1 > 文件 2 | 将文件 1 作为命令的标准输入并将标准输出到文件 2 

**对于输出重定向来讲，用到的符号及其作用如表 3-2 所示:**
符号|作用
-|-
命令 > 文件 |将标准输出重定向到一个文件中（清空原有文件的数据） 
命令 2> 文件| 将错误输出重定向到一个文件中（清空原有文件的数据） 
命令 >> 文件 |将标准输出重定向到一个文件中（追加到原有内容的后面） 
命令 2>> 文件 |将错误输出重定向到一个文件中（追加到原有内容的后面） 
命令 >> 文件 2>&1  或 命令 &>> 文件 |将标准输出与错误输出共同写入到文件中（追加到原有内容的 后面） 

> 注：对于重定向中的标准输出模式，可以省略文件描述符 1 不写，而错误输出模式的文件描述符 2 是必须要写的。

```
man bash > readme.txt 
```
*用输入重定向为C文件提供参数*
```C
#include<stdio.h>

int main(void){
    char c ='';
    c = getchar();
    printf("%c", c);
    return 0;
}
```
```
gcc test.c
./ a.out
输入：f
输出：f
```
*把 readme.txt 文件导入给 wc -l 命令，统计一 下文件中的内容行数*
```
wc -l < readme.tx
```

### 2、管道命令符
> 同时 按下键盘上的 Shift+\键即可输入管道符，其执行格式为“命令 A | 命令 B”。命令符的作用也 可以用一句话来概括“把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输 入
```
grep "/sbin/nologin" /etc/passwd | wc -l 

ls -l /etc/ | more 
```

*在修改用户密码时，通常都需要输入两次密码以进行确认，这在编写自动化脚本时将成为一个非常致命的缺陷。通过把管道符和 passwd 命令的--stdin 参数相结合，我们可以用一条 命令来完成密码重置操作:*
```
echo "linuxprobe" | passwd --stdin root 
```

*在发送电子 邮件时，默认采用交互式的方式来进行*
```
mail -s "Readme" root@linuxprobe.com << over 
```

### 3、命令行的通配符 
> 如果就记得一个文件的开头几个字母，想遍 历查找出所有以这个关键词开头的文件，该怎么操作呢？

*比如，假设想要批量查看所有硬 盘文件的相关权限属性，一种方式是这样的:*

星号（*）代 表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配 0～9 之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配 a、b、c 三个字符中的任意 一个字符
```
ls -l /dev/sda* 
ls -l /dev/sda? 
ls -l /dev/sda[0-9]
```

### 4、常用的转义字符 
> 4 个常用的转义字符如下所示

+ 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。 
+ 单引号（''）：转义其中所有的变量为单纯的字符串。
+ 双引号（""）：保留其中的变量属性，不进行转义处理。 
+ 反引号（``）：把其中的命令执行后返回结果


### 5、重要的环境变量 
> Linux 系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件 存放位置等。 

**在用 户执行了一条命令之后，Linux 系统中到底发生了什么事情呢？简单来说，命令在 Linux 中的 执行分为 4 个步骤.**

1. 判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是的话 则直接执行。
2. Linux 系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。
3. Bash 解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部 的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤 4 继 续处理。
4. 系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作 PATH，可 以简单地把它理解成是“解释器的小助手”，作用是告诉 Bash 解释器待执行的命令可能存放 的位置，然后 Bash 解释器就会乖乖地在这些位置中逐个查找

*PATH 是由多个路径值组成的 变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到 Bash 解释器对 Linux 命令的查找*
```
echo $PATH 
```

**其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自 行创建变量，来满足工作需求。例如设置一个名称为 WORKDIR 的变量，方便用户更轻松地 进入一个层次较深的目录： **
```
mkdir /home/workdir 
WORKDIR=/home/workdir 
cd $WORKDIR 
pwd
```
**但是，这样的变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。 如果工作需要，可以使用 export 命令将其提升为全局变量，这样其他用户也就可以使用它了：**
```
export WORKDIR 
```


-------------------------------------
> 感谢刘遄老师提供的开源优秀教材《Linux就该这么学》www.linuxprobe.com 